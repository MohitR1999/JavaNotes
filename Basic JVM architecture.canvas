{
	"nodes":[
		{"id":"fd57441e4d837f44","type":"group","x":-700,"y":-140,"width":2180,"height":520,"label":"Memory areas of JVM"},
		{"id":"f05ad246576a9354","type":"group","x":-120,"y":-1880,"width":600,"height":1520,"label":"Class loader subsystem"},
		{"id":"49d52123c66517e4","type":"group","x":-740,"y":860,"width":860,"height":860,"label":"Execution engine"},
		{"id":"3e567985e2f234a5","type":"text","text":"**Loading:** \n- It is the process of reading class files and storing corresponding binary data in method area of JVM.\n- For each class file, JVM will store corresponding information in method area\n\t- Fully Qualified name of class\n\t- Fully qualified name of immediate parent class\n\t- Method info, variable info, constructor information\n\t- Modifier information\n\t- Constant pool information\n- After loading .class file, immediately JVM creates an object for that loaded class, on the heap memory of type java.lang.Class\n- The class Class object can be used by the programmer to get class level information like methods info, or variable info, constructors info etc.\n- For every loaded type, only one class Class object will be created, even though we are using the class multiple times in our program","x":-100,"y":-1860,"width":560,"height":560},
		{"id":"7cdd84a2baa19595","type":"text","text":"#### Linking\nLinking consists of 3 activities: verify, prepare and resolve\n- Verification: \n\t- It is the process of ensuring that binary representation of a class is structurally correct, that is, JVM will check whether the .class file is generated by a valid compiler or not, that is, the .class file is properly formatted or not.\n\t- Internally bytecode verifier is responsible for this activity. \n\t- Bytecode verifier is a part of class loader subsystem. \n\t- If verification fails, then we will get runtime exception saying *java.lang.VerifyError*\n- Preparation:\n\t- In this process, JVM will allocate memory for class level static variables and assign default values.\n\t- In initialization phase, original values will be assigned to the static variables.\n- Resolution:\n\t- It is the process of replacing symbolic names in our program with original memory references from method area\n\t- Names of the classes being used in a java program are stored in constant pool of the parent class\n\t- In resolution phase, all these names are replaced with original memory level references from method area","x":-100,"y":-1280,"width":560,"height":720},
		{"id":"be41390f90fcc87f","type":"text","text":"#### Initialization\n- In this phase, all static variables are assigned their original values and static blocks will be executed from parent to child and from top to bottom","x":-100,"y":-540,"width":560,"height":160},
		{"id":"7f10a5f5dc639ebe","type":"text","text":".class file","x":-420,"y":-1160,"width":135,"height":60,"color":"#5b40bf"},
		{"id":"47b92d9e12e87e4d","type":"file","file":"JVM concepts/Types of class loaders.md","x":630,"y":-1900,"width":720,"height":640},
		{"id":"a2fe73d470c71cc6","type":"text","text":"Note: While loading, linking and initialization, if we encounter any error, we will get runtime exception saying *java.lang.LinkageError* ","x":700,"y":-995,"width":580,"height":75,"color":"1"},
		{"id":"ac7eb81fc86f0c16","type":"file","file":"JVM concepts/Memory areas/Method area.md","x":-680,"y":-101,"width":420,"height":440},
		{"id":"e5c05a751e217e24","type":"file","file":"JVM concepts/Memory areas/Heap area.md","x":-240,"y":-100,"width":420,"height":439},
		{"id":"09edb8706c96e8a4","type":"text","text":"**Native method libraries**","x":660,"y":1040,"width":280,"height":60},
		{"id":"65094d3a7468e55b","type":"file","file":"JVM concepts/Memory areas/Stack Memory.md","x":200,"y":-100,"width":420,"height":439},
		{"id":"130e23361702d169","type":"file","file":"JVM concepts/Memory areas/Program Counter (PC) registers.md","x":640,"y":-100,"width":400,"height":439},
		{"id":"6a81c6ef5a75a808","type":"file","file":"JVM concepts/Memory areas/Native method stacks.md","x":1060,"y":-100,"width":400,"height":439},
		{"id":"2f2f2ac40b6af5eb","type":"text","text":"Java Native Interface (JNI)","x":320,"y":1220,"width":276,"height":63},
		{"id":"4801f4757c321d6b","x":-720,"y":883,"width":820,"height":797,"type":"file","file":"JVM concepts/JVM Execution Engine.md"}
	],
	"edges":[
		{"id":"e8aa6c368892884d","fromNode":"7f10a5f5dc639ebe","fromSide":"right","toNode":"f05ad246576a9354","toSide":"left","color":"#510b86"},
		{"id":"3e52e9f57453bd05","fromNode":"f05ad246576a9354","fromSide":"bottom","toNode":"fd57441e4d837f44","toSide":"top","fromEnd":"arrow"},
		{"id":"80bec734be54e524","fromNode":"fd57441e4d837f44","fromSide":"bottom","toNode":"49d52123c66517e4","toSide":"top"},
		{"id":"6033591c1108e223","fromNode":"49d52123c66517e4","fromSide":"top","toNode":"fd57441e4d837f44","toSide":"bottom"},
		{"id":"8b114d87c511ee3d","fromNode":"09edb8706c96e8a4","fromSide":"left","toNode":"2f2f2ac40b6af5eb","toSide":"right"},
		{"id":"821531146db0df49","fromNode":"2f2f2ac40b6af5eb","fromSide":"left","toNode":"49d52123c66517e4","toSide":"right","fromEnd":"arrow"},
		{"id":"f737c749f9511a02","fromNode":"f05ad246576a9354","fromSide":"right","toNode":"47b92d9e12e87e4d","toSide":"left"}
	]
}